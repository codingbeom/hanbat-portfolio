var x=(s,e,h)=>{if(!e.has(s))throw TypeError("Cannot "+h)},t=(s,e,h)=>(x(s,e,"read from private field"),h?h.call(s):e.get(s)),d=(s,e,h)=>{if(e.has(s))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(s):e.set(s,h)},f=(s,e,h,w)=>(x(s,e,"write to private field"),w?w.call(s,h):e.set(s,h),h),k,B=class{constructor(){d(this,k,void 0),this.register=s=>{t(this,k).push(s)},this.unregister=s=>{let e;for(;(e=t(this,k).indexOf(s))!==-1;)t(this,k).splice(e,1)},this.backendChanged=s=>{for(let e of t(this,k))e.backendChanged(s)},f(this,k,[])}};k=new WeakMap;var o,g,c,u,l,W,S,D,y,E,b,O=class M{constructor(e,h,w){if(d(this,o,void 0),d(this,g,void 0),d(this,c,void 0),d(this,u,void 0),d(this,l,void 0),d(this,W,(n,i,r)=>{if(!r.backend)throw new Error(`You must specify a 'backend' property in your Backend entry: ${JSON.stringify(r)}`);let a=r.backend(n,i,r.options),p=r.id,v=!r.id&&a&&a.constructor;if(v&&(p=a.constructor.name),p)v&&console.warn(`Deprecation notice: You are using a pipeline which doesn't include backends' 'id'.
        This might be unsupported in the future, please specify 'id' explicitely for every backend.`);else throw new Error(`You must specify an 'id' property in your Backend entry: ${JSON.stringify(r)}
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-5xx`);if(t(this,c)[p])throw new Error(`You must specify a unique 'id' property in your Backend entry:
        ${JSON.stringify(r)} (conflicts with: ${JSON.stringify(t(this,c)[p])})`);return{id:p,instance:a,preview:r.preview??!1,transition:r.transition,skipDispatchOnTransition:r.skipDispatchOnTransition??!1}}),this.setup=()=>{if(!(typeof window>"u")){if(M.isSetUp)throw new Error("Cannot have two MultiBackends at the same time.");M.isSetUp=!0,t(this,S).call(this,window),t(this,c)[t(this,o)].instance.setup()}},this.teardown=()=>{typeof window>"u"||(M.isSetUp=!1,t(this,D).call(this,window),t(this,c)[t(this,o)].instance.teardown())},this.connectDragSource=(n,i,r)=>t(this,b).call(this,"connectDragSource",n,i,r),this.connectDragPreview=(n,i,r)=>t(this,b).call(this,"connectDragPreview",n,i,r),this.connectDropTarget=(n,i,r)=>t(this,b).call(this,"connectDropTarget",n,i,r),this.profile=()=>t(this,c)[t(this,o)].instance.profile(),this.previewEnabled=()=>t(this,c)[t(this,o)].preview,this.previewsList=()=>t(this,g),this.backendsList=()=>t(this,u),d(this,S,n=>{t(this,u).forEach(i=>{i.transition&&n.addEventListener(i.transition.event,t(this,y))})}),d(this,D,n=>{t(this,u).forEach(i=>{i.transition&&n.removeEventListener(i.transition.event,t(this,y))})}),d(this,y,n=>{var r;let i=t(this,o);if(t(this,u).some(a=>a.id!==t(this,o)&&a.transition&&a.transition.check(n)?(f(this,o,a.id),!0):!1),t(this,o)!==i){t(this,c)[i].instance.teardown(),Object.keys(t(this,l)).forEach(T=>{let m=t(this,l)[T];m.unsubscribe(),m.unsubscribe=t(this,E).call(this,m.func,...m.args)}),t(this,g).backendChanged(this);let a=t(this,c)[t(this,o)];if(a.instance.setup(),a.skipDispatchOnTransition)return;let p=n.constructor,v=new p(n.type,n);(r=n.target)==null||r.dispatchEvent(v)}}),d(this,E,(n,i,r,a)=>t(this,c)[t(this,o)].instance[n](i,r,a)),d(this,b,(n,i,r,a)=>{let p=`${n}_${i}`,v=t(this,E).call(this,n,i,r,a);return t(this,l)[p]={func:n,args:[i,r,a],unsubscribe:v},()=>{t(this,l)[p].unsubscribe(),delete t(this,l)[p]}}),!w||!w.backends||w.backends.length<1)throw new Error(`You must specify at least one Backend, if you are coming from 2.x.x (or don't understand this error)
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-2xx`);f(this,g,new B),f(this,c,{}),f(this,u,[]),w.backends.forEach(n=>{let i=t(this,W).call(this,e,h,n);t(this,c)[i.id]=i,t(this,u).push(i)}),f(this,o,t(this,u)[0].id),f(this,l,{})}};o=new WeakMap,g=new WeakMap,c=new WeakMap,u=new WeakMap,l=new WeakMap,W=new WeakMap,S=new WeakMap,D=new WeakMap,y=new WeakMap,E=new WeakMap,b=new WeakMap,O.isSetUp=!1;var C=O,Y=(s,e,h)=>new C(s,e,h),$=(s,e)=>({event:s,check:e}),J=$("touchstart",s=>{let e=s;return e.touches!==null&&e.touches!==void 0});export{Y as P,J as S};
